# f_and_o_scalping_system/models.py
"""
Core data models for the trading system
"""

from dataclasses import dataclass, field
from datetime import datetime
from typing import Optional, Dict, Any, List
from enum import Enum

class OrderSide(Enum):
    BUY = "BUY"
    SELL = "SELL"

class OrderType(Enum):
    MARKET = "MARKET"
    LIMIT = "LIMIT"
    SL = "SL"
    SL_M = "SL-M"
    BRACKET = "BRACKET"
    CONDITIONAL = "CONDITIONAL"
    MULTI_LEG = "MULTI_LEG"

class OrderStatus(Enum):
    PENDING = "PENDING"
    PLACED = "PLACED"
    FILLED = "FILLED"
    PARTIALLY_FILLED = "PARTIALLY_FILLED"
    CANCELLED = "CANCELLED"
    REJECTED = "REJECTED"
    EXPIRED = "EXPIRED"

class PositionStatus(Enum):
    OPEN = "OPEN"
    PARTIALLY_CLOSED = "PARTIALLY_CLOSED"
    CLOSED = "CLOSED"

class OptionType(Enum):
    CALL = "CE"
    PUT = "PE"

class ExecutionStrategy(Enum):
    MARKET = "MARKET"
    LIMIT = "LIMIT"
    SMART = "SMART"
    TWAP = "TWAP"
    VWAP = "VWAP"
    ICEBERG = "ICEBERG"

class OrderState(Enum):
    CREATED = "CREATED"
    QUEUED = "QUEUED"
    SENT = "SENT"
    PLACED = "PLACED"
    FILLED = "FILLED"
    CANCELLED = "CANCELLED"
    REJECTED = "REJECTED"

class MarketRegime(Enum):
    TRENDING_UP = "TRENDING_UP"
    TRENDING_DOWN = "TRENDING_DOWN"
    RANGING = "RANGING"
    VOLATILE = "VOLATILE"

@dataclass
class Signal:
    """Trading signal generated by strategies"""
    signal_id: str
    strategy_name: str
    symbol: str
    option_type: OptionType
    strike: float
    action: OrderSide
    quality_score: float
    quantity: int
    entry_price: float
    stop_loss_percent: float
    target_percent: float
    time_stop: Optional[datetime] = None
    metadata: Dict[str, Any] = field(default_factory=dict)
    timestamp: datetime = field(default_factory=datetime.now)

    def to_dict(self) -> Dict:
        return {
            'signal_id': self.signal_id,
            'strategy_name': self.strategy_name,
            'symbol': self.symbol,
            'option_type': self.option_type.value,
            'strike': self.strike,
            'action': self.action.value,
            'quality_score': self.quality_score,
            'quantity': self.quantity,
            'entry_price': self.entry_price,
            'stop_loss_percent': self.stop_loss_percent,
            'target_percent': self.target_percent,
            'time_stop': self.time_stop.isoformat() if self.time_stop else None,
            'metadata': self.metadata,
            'timestamp': self.timestamp.isoformat()
        }

@dataclass
class Position:
    """Active trading position"""
    position_id: str
    symbol: str
    option_type: OptionType
    strike: float
    quantity: int
    entry_price: float
    entry_time: datetime
    current_price: float = 0.0
    exit_price: Optional[float] = None
    exit_time: Optional[datetime] = None
    status: PositionStatus = PositionStatus.OPEN
    strategy_name: str = ""
    
    # P&L fields
    unrealized_pnl: float = 0.0
    realized_pnl: float = 0.0
    pnl_percent: float = 0.0
    max_profit: float = 0.0
    max_loss: float = 0.0
    
    # Risk fields
    stop_loss: Optional[float] = None
    target: Optional[float] = None
    trailing_stop: Optional[float] = None
    
    # Metadata
    metadata: Dict[str, Any] = field(default_factory=dict)

    def update_pnl(self, current_price: float):
        """Update P&L calculations - FIXED for options premium vs stock value"""
        self.current_price = current_price
        
        # CRITICAL: For both options and stocks, this calculation is correct:
        # - OPTIONS: entry_price = premium paid, current_price = current premium
        # - STOCKS: entry_price = share price, current_price = current share price
        position_value = self.quantity * self.entry_price
        current_value = self.quantity * current_price
        
        if self.status == PositionStatus.OPEN:
            self.unrealized_pnl = current_value - position_value
            self.pnl_percent = (self.unrealized_pnl / position_value) * 100 if position_value > 0 else 0
            
        # Track extremes
        self.max_profit = max(self.max_profit, self.unrealized_pnl)
        self.max_loss = min(self.max_loss, self.unrealized_pnl)

    def close(self, exit_price: float, exit_time: datetime):
        """Close the position"""
        self.exit_price = exit_price
        self.exit_time = exit_time
        self.status = PositionStatus.CLOSED
        
        position_value = self.quantity * self.entry_price
        exit_value = self.quantity * exit_price
        self.realized_pnl = exit_value - position_value
        self.pnl_percent = (self.realized_pnl / position_value) * 100
        self.unrealized_pnl = 0.0

    def to_dict(self) -> Dict:
        return {
            'position_id': self.position_id,
            'symbol': self.symbol,
            'option_type': self.option_type.value,
            'strike': self.strike,
            'quantity': self.quantity,
            'entry_price': self.entry_price,
            'entry_time': self.entry_time.isoformat(),
            'current_price': self.current_price,
            'exit_price': self.exit_price,
            'exit_time': self.exit_time.isoformat() if self.exit_time else None,
            'status': self.status.value,
            'strategy_name': self.strategy_name,
            'unrealized_pnl': self.unrealized_pnl,
            'realized_pnl': self.realized_pnl,
            'pnl_percent': self.pnl_percent,
            'metadata': self.metadata
        }

@dataclass
class MarketData:
    """Market data snapshot"""
    symbol: str
    timestamp: datetime
    spot_price: float
    ltp: float = 0.0
    bid: float = 0.0
    ask: float = 0.0
    volume: int = 0
    oi: int = 0
    vix: float = 0.0
    
    # OHLC data
    open: float = 0.0
    high: float = 0.0
    low: float = 0.0
    close: float = 0.0
    
    # Derived metrics
    daily_atr: float = 0.0
    hourly_volatility: float = 0.0
    volume_surge: float = 0.0
    
    # Historical data references
    prev_close: float = 0.0
    day_high: float = 0.0
    day_low: float = 0.0

    def to_dict(self) -> Dict:
        return {
            'symbol': self.symbol,
            'timestamp': self.timestamp.isoformat(),
            'spot_price': self.spot_price,
            'ltp': self.ltp,
            'bid': self.bid,
            'ask': self.ask,
            'volume': self.volume,
            'oi': self.oi,
            'vix': self.vix,
            'ohlc': {
                'open': self.open,
                'high': self.high,
                'low': self.low,
                'close': self.close
            },
            'metrics': {
                'daily_atr': self.daily_atr,
                'hourly_volatility': self.hourly_volatility,
                'volume_surge': self.volume_surge
            }
        }

@dataclass
class Order:
    """Enhanced order representation with user-specific information"""
    order_id: str
    user_id: str
    signal_id: Optional[str]
    broker_order_id: Optional[str]
    parent_order_id: Optional[str]
    symbol: str
    option_type: OrderType
    strike: float
    quantity: int
    order_type: OrderType
    side: OrderSide
    price: Optional[float]
    execution_strategy: ExecutionStrategy
    slice_number: Optional[int]
    total_slices: Optional[int]
    state: OrderState
    status: OrderStatus
    filled_quantity: int = 0
    average_price: Optional[float] = None
    fees: float = 0.0
    slippage: float = 0.0
    market_impact: float = 0.0
    strategy_name: Optional[str] = None
    position_id: Optional[str] = None
    created_at: datetime = field(default_factory=datetime.now)
    queued_at: Optional[datetime] = None
    sent_at: Optional[datetime] = None
    placed_at: Optional[datetime] = None
    filled_at: Optional[datetime] = None
    metadata: Dict[str, Any] = field(default_factory=dict)

    def to_dict(self) -> Dict:
        return {
            'order_id': self.order_id,
            'user_id': self.user_id,
            'signal_id': self.signal_id,
            'broker_order_id': self.broker_order_id,
            'parent_order_id': self.parent_order_id,
            'symbol': self.symbol,
            'option_type': self.option_type.value,
            'strike': self.strike,
            'quantity': self.quantity,
            'order_type': self.order_type.value,
            'side': self.side.value,
            'price': self.price,
            'execution_strategy': self.execution_strategy.value,
            'slice_number': self.slice_number,
            'total_slices': self.total_slices,
            'state': self.state.value,
            'status': self.status.value,
            'filled_quantity': self.filled_quantity,
            'average_price': self.average_price,
            'fees': self.fees,
            'slippage': self.slippage,
            'market_impact': self.market_impact,
            'strategy_name': self.strategy_name,
            'position_id': self.position_id,
            'created_at': self.created_at.isoformat(),
            'queued_at': self.queued_at.isoformat() if self.queued_at else None,
            'sent_at': self.sent_at.isoformat() if self.sent_at else None,
            'placed_at': self.placed_at.isoformat() if self.placed_at else None,
            'filled_at': self.filled_at.isoformat() if self.filled_at else None,
            'metadata': self.metadata
        }

@dataclass
class Trade:
    """Represents a completed trade execution"""
    trade_id: str
    order_id: str
    user_id: str
    symbol: str
    option_type: OptionType
    strike: float
    quantity: int
    side: OrderSide
    price: float
    fees: float = 0.0
    slippage: float = 0.0
    market_impact: float = 0.0
    strategy_name: Optional[str] = None
    position_id: Optional[str] = None
    executed_at: datetime = field(default_factory=datetime.now)
    metadata: Dict[str, Any] = field(default_factory=dict)

    def to_dict(self) -> Dict:
        return {
            'trade_id': self.trade_id,
            'order_id': self.order_id,
            'user_id': self.user_id,
            'symbol': self.symbol,
            'option_type': self.option_type.value,
            'strike': self.strike,
            'quantity': self.quantity,
            'side': self.side.value,
            'price': self.price,
            'fees': self.fees,
            'slippage': self.slippage,
            'market_impact': self.market_impact,
            'strategy_name': self.strategy_name,
            'position_id': self.position_id,
            'executed_at': self.executed_at.isoformat(),
            'metadata': self.metadata
        }

@dataclass
class MultiLegOrder:
    """Multi-leg order representation"""
    order_id: str
    user_id: str
    legs: List[Order]
    strategy_name: str
    state: OrderState
    status: OrderStatus
    created_at: datetime = field(default_factory=datetime.now)
    metadata: Dict[str, Any] = field(default_factory=dict)

@dataclass
class BracketOrder:
    """Bracket order representation"""
    order_id: str
    user_id: str
    entry_order: Order
    take_profit_order: Order
    stop_loss_order: Order
    state: OrderState
    status: OrderStatus
    created_at: datetime = field(default_factory=datetime.now)
    metadata: Dict[str, Any] = field(default_factory=dict)

@dataclass
class ConditionalOrder:
    """Conditional order representation"""
    order_id: str
    user_id: str
    trigger_order: Order
    triggered_order: Order
    condition: str
    condition_value: float
    state: OrderState
    status: OrderStatus
    created_at: datetime = field(default_factory=datetime.now)
    metadata: Dict[str, Any] = field(default_factory=dict)


# ===== STANDARDIZED API RESPONSE MODELS =====

@dataclass
class APIResponse:
    """Standardized API response format"""
    success: bool
    message: Optional[str] = None
    data: Optional[Any] = None
    error: Optional[str] = None
    timestamp: str = field(default_factory=lambda: datetime.now().isoformat())
    
    def to_dict(self) -> Dict:
        response = {
            "success": self.success,
            "timestamp": self.timestamp
        }
        if self.message:
            response["message"] = self.message
        if self.data is not None:
            response["data"] = self.data
        if self.error:
            response["error"] = self.error
        return response


def success_response(data: Any = None, message: Optional[str] = None) -> Dict:
    """Helper to create standardized success response"""
    return APIResponse(
        success=True,
        data=data,
        message=message
    ).to_dict()


def error_response(error: str, data: Any = None) -> Dict:
    """Helper to create standardized error response"""
    return APIResponse(
        success=False,
        error=error,
        data=data
    ).to_dict()
